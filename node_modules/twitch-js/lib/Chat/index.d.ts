import EventEmitter from 'eventemitter3';
import { GlobalUserStateMessage, Events, Commands } from '../twitch';
import Client from './Client';
import { EventTypes, ChatOptions, NoticeCompounds, PrivateMessageCompounds, UserNoticeCompounds } from './types';
export * from './types';
/**
 * Interact with Twitch chat.
 *
 * ## Connecting
 *
 * ```js
 * const token = 'cfabdegwdoklmawdzdo98xt2fo512y'
 * const username = 'ronni'
 * const { chat } = new TwitchJs({ token, username })
 *
 * chat.connect().then(globalUserState => {
 *   // Do stuff ...
 * })
 * ```
 *
 * **Note:** Connecting with a `token` and a `username` is optional.
 *
 * Once connected, `chat.userState` will contain
 * [[GlobalUserStateTags|global user state information]].
 *
 * ## Joining a channel
 *
 * ```js
 * const channel = '#dallas'
 *
 * chat.join(channel).then(channelState => {
 *   // Do stuff with channelState...
 * })
 * ```
 *
 * After joining a channel, `chat.channels[channel]` will contain
 * [[ChannelState|channel state information]].
 *
 * ## Listening for events
 *
 * ```js
 * // Listen to all events
 * chat.on('*', message => {
 *   // Do stuff with message ...
 * })
 *
 * // Listen to private messages
 * chat.on('PRIVMSG', privateMessage => {
 *   // Do stuff with privateMessage ...
 * })
 * ```
 *
 * Events are nested; for example:
 *
 * ```js
 * // Listen to subscriptions only
 * chat.on('USERNOTICE/SUBSCRIPTION', userStateMessage => {
 *   // Do stuff with userStateMessage ...
 * })
 *
 * // Listen to all user notices
 * chat.on('USERNOTICE', userStateMessage => {
 *   // Do stuff with userStateMessage ...
 * })
 * ```
 *
 * For added convenience, TwitchJS also exposes event constants.
 *
 * ```js
 * const { chat } = new TwitchJs({ token, username })
 *
 * // Listen to all user notices
 * chat.on(chat.events.USER_NOTICE, userStateMessage => {
 *   // Do stuff with userStateMessage ...
 * })
 * ```
 *
 * ## Sending messages
 *
 * To send messages, [Chat] must be initialized with a `username` and a
 * [`token`](../#authentication) with `chat_login` scope.
 *
 * All messages sent to Twitch are automatically rate-limited according to
 * [Twitch Developer documentation](https://dev.twitch.tv/docs/irc/guide/#command--message-limits).
 *
 * ### Speak in channel
 *
 * ```js
 * const channel = '#dallas'
 *
 * chat
 *   .say(channel, 'Kappa Keepo Kappa')
 *   // Optionally ...
 *   .then(userStateMessage => {
 *     // ... do stuff with userStateMessage on success ...
 *   })
 * ```
 *
 * ### Send command to channel
 *
 * All chat commands are currently supported and exposed as camel-case methods. For
 * example:
 *
 * ```js
 * const channel = '#dallas'
 *
 * // Enable followers-only for 1 week
 * chat.followersOnly(channel, '1w')
 *
 * // Ban ronni
 * chat.ban(channel, 'ronni')
 * ```
 *
 * **Note:** `Promise`-resolves for each commands are
 * [planned](https://github.com/twitch-devs/twitch-js/issues/87).
 *
 * ## Joining multiple channels
 *
 * ```js
 * const channels = ['#dallas', '#ronni']
 *
 * Promise.all(channels.map(channel => chat.join(channel))).then(channelStates => {
 *   // Listen to all messages from #dallas only
 *   chat.on('#dallas', message => {
 *     // Do stuff with message ...
 *   })
 *
 *   // Listen to private messages from #dallas and #ronni
 *   chat.on('PRIVMSG', privateMessage => {
 *     // Do stuff with privateMessage ...
 *   })
 *
 *   // Listen to private messages from #dallas only
 *   chat.on('PRIVMSG/#dallas', privateMessage => {
 *     // Do stuff with privateMessage ...
 *   })
 *
 *   // Listen to all private messages from #ronni only
 *   chat.on('PRIVMSG/#ronni', privateMessage => {
 *     // Do stuff with privateMessage ...
 *   })
 * })
 * ```
 *
 * ### Broadcasting to all channels
 *
 * ```js
 * chat
 *   .broadcast('Kappa Keepo Kappa')
 *   // Optionally ...
 *   .then(userStateMessages => {
 *     // ... do stuff with userStateMessages on success ...
 *   })
 * ```
 */
declare class Chat extends EventEmitter<EventTypes> {
    static Commands: typeof Commands;
    static Events: {
        ANON_GIFT_PAID_UPGRADE: "ANON_GIFT_PAID_UPGRADE";
        GIFT_PAID_UPGRADE: "GIFT_PAID_UPGRADE";
        RAID: "RAID";
        RESUBSCRIPTION: "RESUBSCRIPTION";
        RITUAL: "RITUAL";
        SUBSCRIPTION: "SUBSCRIPTION";
        SUBSCRIPTION_GIFT: "SUBSCRIPTION_GIFT";
        SUBSCRIPTION_GIFT_COMMUNITY: "SUBSCRIPTION_GIFT_COMMUNITY";
        CHEER: import("../twitch").PrivateMessageEvents.CHEER;
        HOSTED_WITHOUT_VIEWERS: import("../twitch").PrivateMessageEvents.HOSTED_WITHOUT_VIEWERS;
        HOSTED_WITH_VIEWERS: import("../twitch").PrivateMessageEvents.HOSTED_WITH_VIEWERS;
        HOSTED_AUTO: import("../twitch").PrivateMessageEvents.HOSTED_AUTO;
        ALREADY_BANNED: "ALREADY_BANNED";
        ALREADY_EMOTE_ONLY_OFF: "ALREADY_EMOTE_ONLY_OFF";
        ALREADY_EMOTE_ONLY_ON: "ALREADY_EMOTE_ONLY_ON";
        ALREADY_R9K_OFF: "ALREADY_R9K_OFF";
        ALREADY_R9K_ON: "ALREADY_R9K_ON";
        ALREADY_SUBS_OFF: "ALREADY_SUBS_OFF";
        ALREADY_SUBS_ON: "ALREADY_SUBS_ON";
        BAD_HOST_HOSTING: "BAD_HOST_HOSTING";
        BAD_MOD_MOD: "BAD_MOD_MOD";
        BAN_SUCCESS: "BAN_SUCCESS";
        BAD_UNBAN_NO_BAN: "BAD_UNBAN_NO_BAN";
        COLOR_CHANGED: "COLOR_CHANGED";
        CMDS_AVAILABLE: "CMDS_AVAILABLE";
        COMMERCIAL_SUCCESS: "COMMERCIAL_SUCCESS";
        EMOTE_ONLY_OFF: "EMOTE_ONLY_OFF";
        EMOTE_ONLY_ON: "EMOTE_ONLY_ON";
        FOLLOWERS_OFF: "FOLLOWERS_OFF";
        FOLLOWERS_ON: "FOLLOWERS_ON";
        FOLLOWERS_ON_ZERO: "FOLLOWERS_ON_ZERO";
        HOST_OFF: "HOST_OFF";
        HOST_ON: "HOST_ON";
        HOSTS_REMAINING: "HOSTS_REMAINING";
        MSG_CHANNEL_SUSPENDED: "MSG_CHANNEL_SUSPENDED";
        MOD_SUCCESS: "MOD_SUCCESS";
        R9K_OFF: "R9K_OFF";
        R9K_ON: "R9K_ON";
        ROOM_MODS: "ROOM_MODS";
        SLOW_OFF: "SLOW_OFF";
        SLOW_ON: "SLOW_ON";
        SUBS_OFF: "SUBS_OFF";
        SUBS_ON: "SUBS_ON";
        TIMEOUT_SUCCESS: "TIMEOUT_SUCCESS";
        UNBAN_SUCCESS: "UNBAN_SUCCESS";
        UNRAID_SUCCESS: "UNRAID_SUCCESS";
        UNRECOGNIZED_CMD: "UNRECOGNIZED_CMD";
        RAW: import("../twitch").ChatEvents.RAW;
        ALL: import("../twitch").ChatEvents.ALL;
        CONNECTED: import("../twitch").ChatEvents.CONNECTED;
        DISCONNECTED: import("../twitch").ChatEvents.DISCONNECTED;
        RECONNECT: import("../twitch").ChatEvents.RECONNECT;
        AUTHENTICATION_FAILED: import("../twitch").ChatEvents.AUTHENTICATION_FAILED;
        ERROR_ENCOUNTERED: import("../twitch").ChatEvents.ERROR_ENCOUNTERED;
        PARSE_ERROR_ENCOUNTERED: import("../twitch").ChatEvents.PARSE_ERROR_ENCOUNTERED;
        MOD_GAINED: import("../twitch").ChatEvents.MOD_GAINED;
        MOD_LOST: import("../twitch").ChatEvents.MOD_LOST;
        USER_BANNED: import("../twitch").ChatEvents.USER_BANNED;
        HOSTED: import("../twitch").ChatEvents.HOSTED;
        CLEAR_CHAT: import("../twitch").BaseCommands.CLEAR_CHAT;
        HOST_TARGET: import("../twitch").BaseCommands.HOST_TARGET;
        NOTICE: import("../twitch").BaseCommands.NOTICE;
        ROOM_STATE: import("../twitch").BaseCommands.ROOM_STATE;
        USER_NOTICE: import("../twitch").BaseCommands.USER_NOTICE;
        USER_STATE: import("../twitch").BaseCommands.USER_STATE;
        WELCOME: import("../twitch").OtherCommands.WELCOME;
        PING: import("../twitch").OtherCommands.PING;
        PONG: import("../twitch").OtherCommands.PONG;
        WHISPER: import("../twitch").OtherCommands.WHISPER;
        GLOBAL_USER_STATE: import("../twitch").TagCommands.GLOBAL_USER_STATE;
        PRIVATE_MESSAGE: import("../twitch").TagCommands.PRIVATE_MESSAGE;
        JOIN: import("../twitch").MembershipCommands.JOIN;
        MODE: import("../twitch").MembershipCommands.MODE;
        PART: import("../twitch").MembershipCommands.PART;
        NAMES: import("../twitch").MembershipCommands.NAMES;
        NAMES_END: import("../twitch").MembershipCommands.NAMES_END;
    };
    static CompoundEvents: {
        [Events.NOTICE]: typeof NoticeCompounds;
        [Events.PRIVATE_MESSAGE]: typeof PrivateMessageCompounds;
        [Events.USER_NOTICE]: typeof UserNoticeCompounds;
    };
    private _options;
    private _log;
    private _client;
    private _readyState;
    private _connectionAttempts;
    private _connectionInProgress;
    private _userState;
    private _channelState;
    private _isDisconnecting;
    /**
     * Chat constructor.
     */
    constructor(maybeOptions: ChatOptions);
    /**
     * Retrieves the current options
     */
    get options(): ChatOptions;
    /**
     * Validates the passed options before changing `_options`
     */
    set options(maybeOptions: ChatOptions);
    /**
     * Connect to Twitch.
     */
    connect: () => Promise<GlobalUserStateMessage>;
    /**
     * Updates the client options after instantiation.
     * To update `token` or `username`, use `reconnect()`.
     */
    updateOptions(options: Partial<ChatOptions>): void;
    /**
     * Send a raw message to Twitch.
     */
    send: Client['send'];
    /**
     * Disconnected from Twitch.
     */
    disconnect: () => void;
    /**
     * Reconnect to Twitch, providing new options to the client.
     */
    reconnect: (newOptions?: ChatOptions) => Promise<{
        roomState: import("../twitch").RoomStateTags;
        userState: import("../twitch").UserStateTags;
    }[]>;
    /**
     * Join a channel.
     *
     * @example <caption>Joining #dallas</caption>
     * const channel = '#dallas'
     *
     * chat.join(channel).then(channelState => {
     *   // Do stuff with channelState...
     * })
     *
     * @example <caption>Joining multiple channels</caption>
     * const channels = ['#dallas', '#ronni']
     *
     * Promise.all(channels.map(channel => chat.join(channel)))
     *   .then(channelStates => {
     *     // Listen to all PRIVMSG
     *     chat.on('PRIVMSG', privateMessage => {
     *       // Do stuff with privateMessage ...
     *     })
     *
     *     // Listen to PRIVMSG from #dallas ONLY
     *     chat.on('PRIVMSG/#dallas', privateMessage => {
     *       // Do stuff with privateMessage ...
     *     })
     *     // Listen to all PRIVMSG from #ronni ONLY
     *     chat.on('PRIVMSG/#ronni', privateMessage => {
     *       // Do stuff with privateMessage ...
     *     })
     *   })
     */
    join: (maybeChannel: string) => Promise<{
        roomState: import("../twitch").RoomStateTags;
        userState: import("../twitch").UserStateTags;
    }>;
    /**
     * Depart from a channel.
     */
    part: (maybeChannel: string) => void;
    /**
     * Send a message to a channel.
     */
    say: (maybeChannel: string, message: string, ...messageArgs: string[]) => Promise<any>;
    /**
     * Whisper to another user.
     */
    whisper: (user: string, message: string) => Promise<any>;
    /**
     * Broadcast message to all connected channels.
     */
    broadcast: (message: string) => Promise<any>;
    private _handleConnectionAttempt;
    private _handleConnectSuccess;
    private _handleJoinsAfterConnect;
    private _handleConnectRetry;
    private _isUserAuthenticated;
    private _emit;
    private _getChannels;
    private _getChannelState;
    private _setChannelState;
    private _removeChannelState;
    private _clearChannelState;
    private _handleMessage;
    private _handleDisconnect;
}
export default Chat;
