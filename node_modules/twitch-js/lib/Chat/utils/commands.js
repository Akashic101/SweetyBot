"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var camelCase_1 = __importDefault(require("lodash/camelCase"));
var toUpper_1 = __importDefault(require("lodash/toUpper"));
var twitch_1 = require("../../twitch");
var utils = __importStar(require("../../utils"));
exports.factory = function (chatInstance) {
    Object.entries(twitch_1.ChatCommands).forEach(function (_a) {
        var key = _a[0], command = _a[1];
        chatInstance[camelCase_1.default(key)] = function (channel) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return chatInstance.say.apply(chatInstance, __spreadArrays([channel, "/" + command], args));
        };
    });
};
exports.resolvers = function (chatInstance) { return function (channel, commandOrMessage) {
    var _a = /^\/(.+)/.exec(commandOrMessage) || [], command = _a[1];
    var notices = Object.entries(twitch_1.KnownNoticeMessageIds).reduce(function (uppercase, _a) {
        var _b;
        var key = _a[0], value = _a[1];
        return (__assign(__assign({}, uppercase), (_b = {}, _b[key] = toUpper_1.default(value), _b)));
    }, {});
    switch (command) {
        case twitch_1.ChatCommands.BAN:
            return [
                utils.resolveOnEvent(chatInstance, notices.BAN_SUCCESS + "/" + channel),
                utils.resolveOnEvent(chatInstance, notices.ALREADY_BANNED + "/" + channel),
            ];
        case twitch_1.ChatCommands.CLEAR:
            return [
                utils.resolveOnEvent(chatInstance, twitch_1.Commands.CLEAR_CHAT + "/" + channel),
            ];
        case twitch_1.ChatCommands.COLOR:
            return [
                utils.resolveOnEvent(chatInstance, notices.COLOR_CHANGED + "/" + channel),
            ];
        case twitch_1.ChatCommands.COMMERCIAL:
            return [
                utils.resolveOnEvent(chatInstance, notices.COMMERCIAL_SUCCESS + "/" + channel),
            ];
        case twitch_1.ChatCommands.EMOTE_ONLY:
            return [
                utils.resolveOnEvent(chatInstance, notices.EMOTE_ONLY_ON + "/" + channel),
                utils.resolveOnEvent(chatInstance, notices.ALREADY_EMOTE_ONLY_ON + "/" + channel),
            ];
        case twitch_1.ChatCommands.EMOTE_ONLY_OFF:
            return [
                utils.resolveOnEvent(chatInstance, notices.EMOTE_ONLY_OFF + "/" + channel),
                utils.resolveOnEvent(chatInstance, notices.ALREADY_EMOTE_ONLY_OFF + "/" + channel),
            ];
        case twitch_1.ChatCommands.FOLLOWERS_ONLY:
            return [
                utils.resolveOnEvent(chatInstance, notices.FOLLOWERS_ON_ZERO + "/" + channel),
                utils.resolveOnEvent(chatInstance, notices.FOLLOWERS_ON + "/" + channel),
            ];
        case twitch_1.ChatCommands.FOLLOWERS_ONLY_OFF:
            return [
                utils.resolveOnEvent(chatInstance, notices.FOLLOWERS_OFF + "/" + channel),
            ];
        case twitch_1.ChatCommands.HELP:
            return [
                utils.resolveOnEvent(chatInstance, notices.CMDS_AVAILABLE + "/" + channel),
            ];
        case twitch_1.ChatCommands.HOST:
            return [
                utils.resolveOnEvent(chatInstance, notices.HOST_ON + "/" + channel),
            ];
        case twitch_1.ChatCommands.MARKER:
            return [Promise.resolve()];
        // case ChatCommands.ME:
        // Use resolver for private messages.
        case twitch_1.ChatCommands.MOD:
            return [
                utils.resolveOnEvent(chatInstance, notices.MOD_SUCCESS + "/" + channel),
                utils.resolveOnEvent(chatInstance, notices.BAD_MOD_MOD + "/" + channel),
            ];
        case twitch_1.ChatCommands.MODS:
            return [
                utils.resolveOnEvent(chatInstance, notices.ROOM_MODS + "/" + channel),
            ];
        case twitch_1.ChatCommands.R9K:
            return [
                utils.resolveOnEvent(chatInstance, notices.R9K_ON + "/" + channel),
                utils.resolveOnEvent(chatInstance, notices.ALREADY_R9K_ON + "/" + channel),
            ];
        case twitch_1.ChatCommands.R9K_OFF:
            return [
                utils.resolveOnEvent(chatInstance, notices.R9K_OFF + "/" + channel),
                utils.resolveOnEvent(chatInstance, notices.ALREADY_R9K_OFF + "/" + channel),
            ];
        case twitch_1.ChatCommands.RAID:
            return [Promise.resolve()];
        case twitch_1.ChatCommands.SLOW:
            return [
                utils.resolveOnEvent(chatInstance, notices.SLOW_ON + "/" + channel),
            ];
        case twitch_1.ChatCommands.SLOW_OFF:
            return [
                utils.resolveOnEvent(chatInstance, notices.SLOW_OFF + "/" + channel),
            ];
        case twitch_1.ChatCommands.SUBSCRIBERS:
            return [
                utils.resolveOnEvent(chatInstance, notices.SUBS_ON + "/" + channel),
                utils.resolveOnEvent(chatInstance, notices.ALREADY_SUBS_ON + "/" + channel),
            ];
        case twitch_1.ChatCommands.SUBSCRIBERS_OFF:
            return [
                utils.resolveOnEvent(chatInstance, notices.SUBS_OFF + "/" + channel),
                utils.resolveOnEvent(chatInstance, notices.ALREADY_SUBS_OFF + "/" + channel),
            ];
        case twitch_1.ChatCommands.TIMEOUT:
            return [
                utils.resolveOnEvent(chatInstance, notices.TIMEOUT_SUCCESS + "/" + channel),
            ];
        case twitch_1.ChatCommands.UNBAN:
            return [
                utils.resolveOnEvent(chatInstance, notices.UNBAN_SUCCESS + "/" + channel),
                utils.resolveOnEvent(chatInstance, notices.BAD_UNBAN_NO_BAN + "/" + channel),
            ];
        case twitch_1.ChatCommands.UNHOST:
            return [
                utils.resolveOnEvent(chatInstance, notices.HOST_OFF + "/" + channel),
            ];
        case twitch_1.ChatCommands.UNMOD:
            return [
                utils.resolveOnEvent(chatInstance, notices.HOST_OFF + "/" + channel),
            ];
        case twitch_1.ChatCommands.UNRAID:
            return [
                utils.resolveOnEvent(chatInstance, notices.UNRAID_SUCCESS + "/" + channel),
            ];
        // Resolver for private messages.
        default:
            return [
                utils.resolveOnEvent(chatInstance, twitch_1.Commands.USER_STATE + "/" + channel),
            ];
    }
}; };
//# sourceMappingURL=commands.js.map